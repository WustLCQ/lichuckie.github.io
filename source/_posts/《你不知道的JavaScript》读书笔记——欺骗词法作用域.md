---
title: 《你不知道的JavaScript》读书笔记——欺骗词法作用域
date: 2020-05-26 17:35:47
tags: [JavaScript, 你不知道的JavaScript, 作用域]
categories: 读书笔记
---

JavaScript是词法作用域，变量的作用域由代码位置所决定，这是在面试中经常会考到的一个知识点。阅读《你不知道的JavaScript》一书时，发现运行时是可以欺骗词法作用域的，这是之前的知识盲区。主要是因为欺骗词法作用域的方法是`eval`和`with`两种手段，而在学习JavaScript初期就被警告不要用`eval`和`with`，对这两块的知识点一直掌握不够。

## eval

JavaScript 中的`eval(..)`函数可以接受一个字符串为参数，并将其中的内容视为好像在书 写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并 运行，就好像代码是写在那个位置的一样。

根据这个原理来理解`eval(..)`，它是如何通过代码欺骗和假装成书写时(也就是词法期) 代码就在那，来实现修改词法作用域环境的，这个原理就变得清晰易懂了。
在执行`eval(..)`之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插 入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

考虑以下代码:
```javascript
function foo(str, a) {
    eval( str ); // 欺骗! console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```
`eval(..)`调用中的`var b = 3;`这段代码会被当作本来就在那里一样来处理。由于那段代 码声明了一个新的变量`b`，因此它对已经存在的 `foo(..)`的词法作用域进行了修改。事实上，和前面提到的原理一样，这段代码实际上在`foo(..)`内部创建了一个变量`b`，并遮蔽了外部(全局)作用域中的同名变量。
当`console.log(..)`被执行时，会在`foo(..)`的内部同时找到`a`和`b`，但是永远也无法找到外部的`b`。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。

默认情况下，如果`eval(..)`中所执行的代码包含有一个或多个声明(无论是变量还是函 数)，就会对`eval(..)`所处的词法作用域进行修改。技术上，通过一些技巧(已经超出我 们的讨论范围)可以间接调用`eval(..)`来使其运行在全局作用域中，并对全局作用域进行 修改。但无论何种情况，`eval(..)`都可以在运行期修改书写期的词法作用域。

在严格模式的程序中，`eval(..)`在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。
```javascript
function foo(str) {
    "use strict";
    eval( str );
    console.log( a ); // ReferenceError: a is not defined
}
foo( "var a = 2" );
```

JavaScript中还有其他一些功能效果和`eval(..)`很 相 似。`setTimeout(..)`和`setInterval(..)`的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的 函数代码。这些功能已经过时且并不被提倡。不要使用它们!
`new Function(..)`函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比`eval(..)`略微安全一些，但也要尽量避免使用。
在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

## with

JavaScript中另一个难以掌握(并且现在也不推荐使用)的用来欺骗词法作用域的功能是`with`关键字。可以有很多方法来解释`with`，在这里我选择从这个角度来解释它:它如何同被它所影响的词法作用域进行交互。
`with`通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

比如:
```javascript
var obj = {
    a: 1,
    b: 2,
    c: 3
};
// 单调乏味的重复 "obj" obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}
```
但实际上这不仅仅是为了方便地访问对象属性。考虑如下代码:
```javascript
function foo(obj) {
    with (obj) {
        a = 2;
    }
}
var o1 = {
    a: 3
};
var o2 = {
    b: 3
};
foo( o1 );
console.log( o1.a ); // 2
foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了!
```

这个例子中创建了`o1`和`o2`两个对象。其中一个具有`a`属性，另外一个没有。`foo(..)`函数接受一个obj参数，该参数是一个对象引用，并对这个对象引用执行了`with(obj) {..}`。 在`with`块内部，我们写的代码看起来只是对变量`a`进行简单的词法引用，实际上就是一个 LHS 引用(查看第 1 章)，并将 2 赋值给它。

当我们将`o1`传递进去，`a=2`赋值操作找到了`o1.a`并将`2`赋值给它，这在后面的`console. log(o1.a)`中可以体现。而当`o2`传递进去，`o2`并没有`a`属性，因此不会创建这个属性，`o2.a`保持`undefined`。

但是可以注意到一个奇怪的副作用，实际上`a = 2`赋值操作创建了一个全局的变量`a`。这是怎么回事?

`with`可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

尽管`with`块可以将一个对象处理为词法作用域，但是这个块内部正常的`var`声明并不会被限制在这个块的作用域中，而是被添加到`with`所处的函数作用域中。

`eval(..)`函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。

可以这样理解，当我们传递`o1`给`with`时，`with`所声明的作用域是`o1`，而这个作用域中含有一个同`o1.a`属性相符的标识符。但当我们将`o2`作为作用域时，其中并没有`a`标识符， 因此进行了正常的LHS标识符查找(查看第 1 章)。

`o2`的作用域、`foo(..)`的作用域和全局作用域中都没有找到标识符`a`，因此当`a=2`执行 时，自动创建了一个全局变量(因为是非严格模式)。

`with`这种将对象及其属性放进一个作用域并同时分配标识符的行为很让人费解。但为了说明我们所看到的现象，这是我能给出的最直白的解释了。

另外一个不推荐使用`eval(..)`和`with`的原因是会被严格模式所影响(限制)。`with`被完全禁止，而在保留核心功能的前提下，间接或非安全地使用`eval(..)`也被禁止了。

## 性能

`eval(..)`和`with`会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。

你可能会问，那又怎样呢?如果它们能实现更复杂的功能，并且代码更具有扩展性，难道不是非常好的功能吗?答案是否定的。

JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了`eval(..)`或`with`，它只能简单地假设关于标识符位置的判断 都是无效的，因为无法在词法分析阶段明确知道 `eval(..)`会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给`with`用来创建新词法作用域的对象的内容到底 是什么。

最悲观的情况是如果出现了`eval(..)`或`with`，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。

如果代码中大量使用`eval(..)`或`with`，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。